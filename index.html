<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Управление персонажем одной рукой</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      border: 2px solid #555;
      position: relative;
    }
    #webcamContainer {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 200px;
      border: 2px solid #fff;
      z-index: 1000;
    }
    #webcam,
    #output_canvas {
      width: 100%;
      height: auto;
      display: block;
      transform: scaleX(-1);
    }
    #dataPanel {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 1000;
    }
    #zoneOverlay {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      pointer-events: none;
      transform: scaleX(1);
    }
    .zone {
      position: absolute;
      top: 0;
      bottom: 0;
      opacity: 0.3;
      color: rgb(0, 0, 0);
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      font-size: 16px;
    }
    .left-zone {
      left: 0;
      width: 40%;
      background: rgba(255, 0, 0, 0.3);
    }
    .center-zone {
      font-size: 10px;
      left: 40%;
      width: 20%;
      background: rgba(0, 255, 0, 0.3);
    }
    .right-zone {
      left: 60%;
      width: 40%;
      background: rgba(0, 0, 255, 0.3);
    }
    /* Стиль для сообщения о победе */
    #winMessage {
      position: absolute;
      top: 50%;
      left:50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: green;
      background: rgba(255,255,255,0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <p>✊ til að hoppa</p>
  <p>Hreifðu hönd til að styra</p>
  <button id="webcamButton" style="position:fixed;top:10px;left:220px;z-index:1100;">ENABLE WEBCAM</button>
  
  <div id="webcamContainer">
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="output_canvas"></canvas>
    <div id="zoneOverlay">
      <div class="zone left-zone">Vinstri</div>
      <div class="zone center-zone">Stopp</div>
      <div class="zone right-zone">Hægri</div>
    </div>
  </div>

  <div id="dataPanel">
    <div>Gesture: <span id="gesture_output"></span></div>
    <div>X: <span id="x_output"></span></div>
    <div>Y: <span id="y_output"></span></div>
  </div>
  
  <div id="winMessage">Þú vannst! Notaðu ✌️ til að byrja aftur</div>
  
  <svg id="game" viewBox="0 0 800 400">
    
    <g id="background">
      <rect x="0" y="0" width="1600" height="400" fill="skyblue" />
      <circle cx="100" cy="80" r="20" fill="white">
        <animate attributeName="cx" from="100" to="900" dur="20s" repeatCount="indefinite" />
      </circle>
      <circle cx="300" cy="60" r="15" fill="white">
        <animate attributeName="cx" from="300" to="1100" dur="25s" repeatCount="indefinite" />
      </circle>
      <circle cx="500" cy="100" r="25" fill="white">
        <animate attributeName="cx" from="500" to="1300" dur="30s" repeatCount="indefinite" />
      </circle>
    </g>
    <g id="gameScene">
      <rect x="0" y="350" width="1600" height="50" fill="#654321" />
      <rect class="obstacle" x="300" y="320" width="30" height="30" fill="red" />
      <rect class="obstacle" x="500" y="220" width="30" height="70" fill="red" />
      <rect class="obstacle" x="700" y="320" width="30" height="30" fill="red" />
      <rect class="obstacle" x="900" y="320" width="30" height="30" fill="red" />
      <rect class="obstacle" x="1100" y="220" width="30" height="70" fill="red" />
      <rect class="obstacle" x="1300" y="320" width="30" height="30" fill="red" />
      <rect id="finishLine" x="1550" y="250" width="10" height="100" fill="gold" />
      <text id="finishText" x="1520" y="240" fill="black" font-size="16" transform="rotate(-90 1520,240)">FINISH</text>
      <circle id="player" cx="50" cy="320" r="20" fill="blue" />
    </g>
  </svg>
  
  <script type="module">
    import { GestureRecognizer, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';

    let gestureRecognizer;
    let runningMode = 'IMAGE';
    let webcamRunning = false;
    const videoWidth = 480;
    const videoHeight = 360;
    
    let currentLandmarks = null;  
    let currentGesture = "";      

    const createGestureRecognizer = async () => {
      const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');
      gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task',
          delegate: 'GPU'
        },
        runningMode: runningMode
      });
    };
    createGestureRecognizer();

    const video = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    canvasElement.width = videoWidth;
    canvasElement.height = videoHeight;
    const canvasCtx = canvasElement.getContext('2d');
    const gestureOutput = document.getElementById('gesture_output');
    const xOutput = document.getElementById('x_output');
    const yOutput = document.getElementById('y_output');

    const enableWebcamButton = document.getElementById('webcamButton');
    enableWebcamButton.addEventListener('click', enableCam);

    function enableCam(event) {
      if (!gestureRecognizer) {
        alert('Подождите, модель загружается');
        return;
      }
      if (!webcamRunning) {
        webcamRunning = true;
        enableWebcamButton.style.display = 'none';
        const constraints = { video: { width: videoWidth, height: videoHeight } };
        navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
          video.srcObject = stream;
          video.addEventListener('loadeddata', predictWebcam);
        });
      }
    }

    let lastVideoTime = -1;
    let results = undefined;
    async function predictWebcam() {
      if (runningMode === 'IMAGE') {
        runningMode = 'VIDEO';
        await gestureRecognizer.setOptions({ runningMode: 'VIDEO' });
      }
      const nowInMs = Date.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        results = gestureRecognizer.recognizeForVideo(video, nowInMs);
      }

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      const drawingUtils = new DrawingUtils(canvasCtx);
      if (results.landmarks) {
        for (const landmarks of results.landmarks) {
          drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
            color: '#00FF00',
            lineWidth: 3
          });
          drawingUtils.drawLandmarks(landmarks, {
            color: '#FF0000',
            lineWidth: 1
          });
        }
      }
      canvasCtx.restore();

      if (results.landmarks && results.landmarks.length > 0) {
        currentLandmarks = results.landmarks[0];
        xOutput.innerText = (currentLandmarks[0].x * 100).toFixed(2);
        yOutput.innerText = (currentLandmarks[0].y * 100).toFixed(2);
      } else {
        currentLandmarks = null;
      }
      if (results.gestures.length > 0) {
        currentGesture = results.gestures[0][0].categoryName;
        gestureOutput.innerText = currentGesture;
      } else {
        currentGesture = "";
        gestureOutput.innerText = "";
      }
      
      if (webcamRunning) {
        window.requestAnimationFrame(predictWebcam);
      }
    }

    const gameSvg = document.getElementById('game');
    const player = document.getElementById('player');
    const winMessage = document.getElementById('winMessage');
    let playerPos = { x: 100, y: 320 };
    let playerVel = { x: 0, y: 0 };
    const gravity = 0.5;
    let onGround = true;
    let jumpCooldown = false; 
    const finishThreshold = 1550; 

    let restartCooldown = false;
    function restartGame() {
      if (restartCooldown) return;
      restartCooldown = true;
      playerPos = { x: 100, y: 320 };
      playerVel = { x: 0, y: 0 };
      onGround = true;
      jumpCooldown = false;
      winMessage.style.display = 'none';
      currentGesture = "";
      setTimeout(() => { restartCooldown = false; }, 1000);
    }

    function gameLoop() {
      if (playerPos.x >= finishThreshold) {
        winMessage.style.display = 'block';
      }
      if (winMessage.style.display === 'block') {
        if (currentGesture.toLowerCase() === 'victory') {
          restartGame();
        }
        requestAnimationFrame(gameLoop);
        return;
      }
      
      if (currentLandmarks) {
        const handX = currentLandmarks[0].x * 100;
        if (handX > 40 && handX < 60) {
          playerVel.x = 0;
        } else if (handX < 40) {
          playerVel.x = 5;
        } else if (handX > 60) {
          playerVel.x = -5;
        }
      } else {
        playerVel.x = 0;
      }
    
      if (currentGesture.toLowerCase() === "closed_fist" && onGround && !jumpCooldown) {
        playerVel.y = -10;
        onGround = false;
        jumpCooldown = true;
        setTimeout(() => { jumpCooldown = false; }, 500);
      }
    
      playerVel.y += gravity;
      playerPos.x += playerVel.x;
      playerPos.y += playerVel.y;
    
      if (playerPos.y >= 320) {
        playerPos.y = 320;
        playerVel.y = 0;
        onGround = true;
      }
      if (playerPos.x < 20) playerPos.x = 20;
      if (playerPos.x > 1600 - 20) playerPos.x = 1600 - 20;
    
      const obstacles = document.querySelectorAll('.obstacle');
      obstacles.forEach(obstacle => {
        const ox = parseFloat(obstacle.getAttribute('x'));
        const oy = parseFloat(obstacle.getAttribute('y'));
        const ow = parseFloat(obstacle.getAttribute('width'));
        const oh = parseFloat(obstacle.getAttribute('height'));
        if (
          playerPos.x + 20 > ox &&
          playerPos.x - 20 < ox + ow &&
          playerPos.y + 20 > oy &&
          playerPos.y - 20 < oy + oh
        ) {
          playerPos = { x: 100, y: 320 };
        }
      });
    
      player.setAttribute('cx', playerPos.x);
      player.setAttribute('cy', playerPos.y);
    
      let viewBoxX = playerPos.x - 100;
      if(viewBoxX < 0) viewBoxX = 0;
      if(viewBoxX > 1600 - 800) viewBoxX = 1600 - 800;
      gameSvg.setAttribute('viewBox', `${viewBoxX} 0 800 400`);
    
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
